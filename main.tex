\documentclass{article}
\usepackage[utf8]{inputenc}


\usepackage{natbib}
\usepackage{graphicx}
\usepackage{listings, hyperref}
\usepackage{verbatim}

\title{[TER] Dictionnaire \\
Ordonnanceur centralisé}
\author{Adam GARCIA \\
        Charles BENAIS}
\date{March-May 2017}

\begin{document}

\maketitle
\pagebreak
\tableofcontents


\pagebreak

\part{Contexte du projet}
Un workflow à base de composants est une représentation en XML d'un assemblage de composants tel que celui-ci où l'on imagine un producteur-consommateur simple :
\begin{verbatim}
<assembly>
  <declare>
    <component name="RandomNumbersGen">
      <dataOut name="rand" type="double"/>
    </component>

    <component name= "NumbersPlotter">
      <dataIn name="plotNumber" type="double"/>
    </component>

    <instance name="producer" componentRef="RandomNumbersGen" path="?" signature="?"/>
    <instance name="consummer" componentRef="NumbersPlotter" path="?" signature="?"/>

    <configport>
      <inout>
         <setPort in="producer.rand" out="consummer.plotter"/>
      </inout>
    </configport>
  </declare>

  <instruction>
    <sequence>
      <exectask nameInstance="producer"/>
      <exectask nameInstance="consummer"/>
    </sequence>
  </instruction>
</assembly>
\end{verbatim}


\newpage

\section{Bases lexicales}
\begin{itemize}

    \item \textbf{Composants} :\\
    Les composants sont des "boîtes noires" dont nous ne soucions pas de l'implémentation.

    \item \textbf{Pré-traitement de l'assemblage XML de composants:}\\
    Etape de transfert du XML vers une représentation à base d'objet.\\
    Elle permet actuellement de travailler en C++ un assemblage de composants issu d'un XML et éventuellement d'en re-générer un fichier XML.\\
    Elle pourrait dès-lors permettre une représentation graphique et la génération complète d'un assemblage valide correspondant.\\
    Elle permettra la génération d'un ordonnanceur...

    \item \textbf{Ordonnanceur :}\\
    Orchestration du workflow de composants : instanciation, gestion des transferts de données entrantes/sortantes et terminaison.\\
    Permet aussi d'allouer les ressources et leurs libérations.\\
    L'ordonnancement d'un workflow est issue d'une stratégie d'éxécution que l'on doit définir à l'aide "d'actions de gestion"% j'aimerai une liste de ce que fourni un composant pour établir la liste des opérations que devra fournir l'ordonnanceur

    \item \textbf{Entrée/sortie :}\\
    Appel d'une \textbf{opération} au travers d'une \textbf{interface} permettant de transférer les \textbf{données} d'une \textbf{instance} à une autre.

    \item \textbf{Opération/fonction/méthode :}\\
    Appel permettant de réaliser une action.

    \item \textbf{Interfaces :}\\
    Interface stipulant les fonctions et opérations utilisable ainsi que ce qu'elles renvoient.% ou ça ?

    \item \textbf{Donnée :}\\
    Unité de base, number ou string.% à voir pour étendre aux classes et objets...

    \item \textbf{Instances :}\\
    Un composant instancié est créé mais non démarré..% j'ai pas compris

\end{itemize}



\pagebreak



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\iffalse
\section{L'existant}
\subsection{Workflow orienté DataFlow - les flux de donnée}
\subsubsection{Description générale}
DataFlow/Explicitation des dépendance de données/flux de données : \\
    Il s'agit des liaison entre chaque port de notre workflow, c'est ce qui détermine qu'elles sont les données à transférer et ou les transférer.
\subsubsection{L'intérêt du modèle}
\subsubsection{Exemples de technologie basé sur DataFlow}
\subsection{Workflow orienté ControlFlow - les flux de contrôle}
\subsubsection{Description générale}
\subsubsection{L'intérêt du modèle}
\subsubsection{Exemples de technologie basé sur DataFlow}
\subsection{La notion spatiale}
Notion spatiale : (appel de service)\\
    La notion spaciale est la notion dans laquelle une connections s'établi entre deux composant sous forme d'appel de service, c'est à dire le composant appeler doit être créer avant l'appelant pour lui fournir les données qu'il désire avoir, ils sont en lien direct au travers de leurs port client/serveur pour le moment non encore défini.
\subsection{La notion temporelle}
Notion temporelle : (Dataflow et controlFlow)\\
    Workflow "classique" la notion temporelle signifie qu'une tâche attend la fin d'une autre pour commencer car elle a besoin des données de la tâche précédente.
\subsection{Les ressources}
\section{Travail théorisé}
\subsection{Mise en corrélation des concepts}
\subsection{STCM théorisé par Hinde Bouzianne}
\subsection{Simplification des notions de cette théorisation}
\subsection{Objectif du projet au travers de la grammaire et des principes simplifié}
\fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





\section{Définition d'une grammaire simplifiée}
$<assembly>$ :\\
Permet l'association d'un simple data-flow à un control-flow.\\
Le premier, par une partie \textbf{déclaration} permettant la génération de code qui lierait les ports de différentes instances de composants en fonction du second, une partie \textbf{instruction} qui conditionne l'exécution des composants.\\

$<declare>$, c'est la partie déclarative de l'assemblage; Elle contient :
\begin{itemize}
    \item $<component>$ :
    Offre l'interface des ports d'une instance de composant.\\
    Permet de déterminer les données attendues pour effectuer son traitement, et les données renvoyées par l'instance à la fin de son traitement. % j'ai pas compris les données renvoyées ? comment savoir qu'elle a fini son exécution ? ou alors l'opération qu'elle implémente est a-synchrone et permet de réaliser une attente à la demande de l'ordonnanceur ??
    \begin{itemize}
        \item name : permet de référer une instance à une interface par son nom.
        \item $<port>$* : Description des ports (données requises et produites)
        Permet d'avoir un type générique qu'il s'agisse de ports d'entrée ou de sortie.\\
        En effet l'ordonnanceur n'ayant qu'un rôle d'intermédiaire, il n'as pas à connaître le type réel des données manipulées autrement que dans un souci de vérification statique de code.
        Il faut comprendre ici que on récupère la data dans du (void)char* et qu'on renvoit du (void)char*.\\
        \begin{itemize}
            \item $<dataIn>$ $\rightarrow$ Données requises par le composant :\\
            Les ports d’entrées sont rattachés à des données en entrée qui, à leur arrivée, permettent de déclencher l’exécution de la tâche.
            %Signifie que le composant qui aura ce port associé implémentera un type opaque (car cela peut être une interface, un service web...), qui lui même implémentera des opérations spécifique, qui permettrons la réception de donnée lorsqu'un appel sera effectué de manière externe.

            \item $<dataOut>$ $\rightarrow$ Donnée sortante d'un composant  :\\
            Les ports de sortie sont rattachés aux données produites par la tâche, et permettent de déterminer la fin de son exécution. Ces ports, si une connexion a été établie avec un autre port, permettent la communication de données via un protocole déterminé.
            \begin{itemize}
                \item name : Nom du port.
                \item type : Type de la valeur associée au port, cela peut être un type de base (nombre, chaine de caractères..), voir un type plus complexe (structure, objet..).
            \end{itemize}
        \end{itemize}
    \end{itemize}

    \item $<instances>$ :
    Une instance est vue, au même titre que le composant, comme une boîte-noire.\\
    Elle permet la création et la manipulation du composant au travers d'un type opaque RefInstance dont on ne se soucie pas de l'implémentation.\\
    Plusieurs instances d'un même composant peuvent-être créés, leurs noms doivent être différents..
    \begin{itemize}
        \item name : Nom de l'instance.
        \item ComponentRef : Nom du composant (interface) implémentée par l'instance.
        \item path : Chemin d'accès à la ressource qui permet de démarrer le composant
        \item signature : C'est la spécification de la technologie et/ou du langage dans lequel a été implémentée l'instance. Chemin d'accès du fichier déterminant les spécification de l'application à lancer (version, ressources nécessaires..).
    \end{itemize}


    % ------------------------------------------ %
    % A FAIRE %


    \item $<configPorts>$ :\\
    Sert à indiquer les liaisons de données entre les ports des composants (à orchestrer en fonction de leurs disponibilité), c'est un graphe orienté que l'on suppose a-cyclique.
    \begin{itemize}
        \item $<inOut>$ :\\
        Suppose des appels locaux (non-distants); peut prendre deux types d'entrées:
        \begin{itemize}
            \item $<setPort>$ Exprime la liaison ports d'entrées et de sorties d'instances de composants :
            \begin{itemize}
                \item in : Port d'une instance qui attend des données.
                \item out : Port d'une instance sur lequel on pourra récupérer des données.
            \end{itemize}
        \end{itemize}
        Ceux-ci ont pour but d'avoir un seul attribut générique pour les entrées/sorties du data-flow au sein des configPorts qui, à terme, devraient pouvoir différencier plusieurs types de ports (clients/serveurs non abordés pour le moment).
    \end{itemize}

    \item Les instructions :
    \begin{itemize}
        \item $<CreateInstance>$ :\\
        \item $<ExecTask>$ :\\
        \item $<Sequence>$ :\\
        \item $<Parrallélle>$ :\\
    \end{itemize}
\end{itemize}




\pagebreak




\section{Actions de Gestion}
\textbf{TODO};

\section{Stratégie d'exécution}
On peut partir du plus trivial hello world :
\begin{verbatim}
<!-- proof of concept: on imagine un composant qui retourne "Hello, World" -->
<assembly>
  <declare>
    <component name= "IHello">
      <dataOut name="helloVar" type="string"/>
    </component>

    <instance name="clientHello" componentRef="IHello" path="?" signature="?"/>

    <!-- Pas de configport -->
  </declare>

  <instruction>
    <exectask nameInstance="clientHello"/>
  </instruction>
</assembly>
\end{verbatim}
\textbf{N'à pas lieu d'exister puisque pas de configport ?}


\newpage


On reprends l'exemple de l'introduction :
\begin{verbatim}
<assembly>
  <declare>
    (...)
    <configport>
      <inout>
         <setPort in="producer.rand" out="consummer.plotter"/>
      </inout>
    </configport>
  </declare>

  <instruction>
    <sequence>
      <exectask nameInstance="producer"/>
      <exectask nameInstance="consummer"/>
    </sequence>
  </instruction>
</assembly>
\end{verbatim}




%\item $<unSetPorts>$ :  Cela représente la fin de la liaison entre deux ports donnés. Si une balise $<setPorts>$ est définie avec les deux ports on ne le prend plus en considération. Dans le cas ou aucune balise $<setPort>$ qui prend les deux ports n'existe alors cette balise est inutile. Permettent de coupé dynamiquement le dataflow. Prend les paramètres sous une forme similaire à la balise $<setPort>$.












% -----------(commenté jusqu'à la fin)-------------- %
\iffalse
\pagebreak
\part{Contribution au développement de l'architecture et des concepts permettant de théorisé l'utilisation du langage redéfinie}
\section{Choix de structure de représentation du XML}
\subsection{Les piles}
\subsection{Les graphes}
\subsection{Les tableaux dynamique}

\subsection{La représentation choisie - Objet}
Nous avons choisi de transférer le XML en objet et ce afin de pouvoir obtenir une structure manipulable depuis le code avec plus d'aisance, il s'agit du notre premier pré-traitement. Ainsi nous avons créer un diagramme UML modélisant la grammaire nettoyée que nous devons utilisée, observable figure 1.

\subsection{Avantages}
\begin{itemize}
    \item Facilité de représentation et de manipulation.
    \item Rentre bien dans le sens du projet grâce a l'héritage, qui nous permet pour les instructions d'avoir de l'adaptabilité, comme on peut le voir l'assemblage et les séquences peuvent contenir des instructions telle que exectask ou séquence mais ne peuvent en aucun cas contenir une instruction qui est juste une instruction.
    \item Permet une extension simplifié de nos concept, permettant ainsi l'ajout des concepts dont on a fait le choix de ce passer, par exemple la notion spatiale avec la notion de client et de serveur peut facilement être gérée grâce au modèle objet qui permettra une intégration simplifié.
\end{itemize}

\subsection{Limites}
\begin{itemize}
    \item Potentiellement plus difficile à manipuler lorsque nous chercherons à exécuter notre workflow dans l'univers distribué.
    \item "Lourdeur" de l'objet, en effet il peut s'avérer parfois compliqué d'effectuer des actions lorsque les objet sont imbriqué les uns les autres.
    \item Autres défaut ?
\end{itemize}

\subsection{Conclusion : le pourquoi de l'objet}
L'objet semble être la représentation qui convient le mieux a notre projet, de plus par notre cursus c'est également la représentation que nous avons le plus l'habitude de manipuler et de concevoir. L'UML que nous avons mis en place est donc d'autant plus intéressant car il est compréhensible par le plus grand nombre, celui ci étant l'application des connaissances apprise lors de notre parcourt. Dans une optique de reprise du projet il nous a donc sembler fort intéressant d'utiliser l'objet afin d'avoir une structure manipulable par le plus grand nombre, et explicitant les données d'origine au maximum.

\section{Parser XML to Object}
\subsection{Les outils de parsage XML}
\subsection{Outils de vérification de la validité XML}
\subsection{Réalisation}


\begin{figure}[]
\centering
\begin{changemargin}{-75px}{0px}
\includegraphics[width=500px]{uml.png}
\end{changemargin}
\caption{UML de la représentation objet de la structure XML}
\label{figure1}
\end{figure}

\pagebreak

\section{Gestion des balises au sein de l'ordonnanceur}

\subsection{$<component>$}
    Seul l'objet sera utilisé afin de connaître les caractéristique attendu, des instances qui instancie ce composant, mais en aucun cas cet objet sera "directement" utilisé, il permet uniquement de connaître les structures.

\subsection{$<dateIn>$}

    Signifie que l'on a une référence de port sur laquelle on peut appeler des opérations qui permettent d'effectuer un envoie de données sur le composant, cette opération implémente la réception.\\
    Comme nous disposons de la référence du port ainsi que la référence du composant auquel le port est associé, nous avons la possibilité d'effectuer un appel permettant de positionner les données que l'on désire sur le port et de ainsi permettre de donner l'accès à des ressources nécessaire au fonctionnement d'une tâche du composant.\\
    Une connexion est également réalisable entre un port d'entrée et un port de sorti auquel cas le transfert des données ce réalise automatiquement.
    \subsection{$<dataOut>$}
    deux possibilités
    \begin{itemize}
            \item Soit on veut établir les liaison directement entre les composant lorsque c'est possible, au quel cas on mettra en place une connexion pour chaque port de sorti avec tout les ports d'entrée d'autre composant qui attendent la donnée du port de sorti. Cette connexion doit pouvoir s'effectuer quelque soit le type de technologie choisie mais il s'agit pour nous d'une connexion entre deux références de ports, ceci offrant une opération de connexion ayant une forme déterminée.
            \item Soit on veut centraliser les ressources disponible au sein de l'ordonnanceur afin de les redistribuer, au quel cas l'ordonnanceur doit, pour chaque port de sortis créer un port interne avec lequel il établira une connexion référence à référence avec le port de sorti, afin que lorsqu'une donnée soit placé sur le port de sortie il y est un transfert de cette donnée vers le port de l'ordonnanceur.
        \end{itemize}

    \subsection{$<instance>$}
    Au sein de l'ordonnanceur les instances sont manipuler par leurs objets pour connaître leurs caractéristiques et effectuer l'opération de mise en place de l'instance sur une machine donnée avec l'allocation des ressources, mais pour ce qui est de autres opération effectuée déçu on utilisera la référence de l'instance obtenu avec la première opération, qui permettra de retrouver les ports de cette instances ou encore de la terminer.


    \subsection{$<setPort>$}
    Au niveau de l'ordonnanceur cela signifie qu'on devra récupérer les deux références de ports en questions à l'aide d'un appel de getPorts() sur les références d'instances concernées par cette liaison. Puis à l'aide de leur opération obligatoirement fourni effectuer une connexion entre les deux port de manière à ce que le port de sorti communique les données au port d'entrée. Cette connexion peut s'effectuer de manière directe, si au moment ou l'on veut établir la connexion, les deux instances sont en train de fonctionner sur des machines, ou de manière indirecte lorsque l'instance dont le port attend les données n'est pas en train de fonctionner (ou qu'on ne veut simplement pas effectuer de liaison directe), au quel cas on centralisera l'envoie de cette donnée sur l'ordonnanceur à l'aide d'un port spécifiquement créer pour l'occasion sur l'ordonnanceur qui sera à la fois un port d'entrée et de sorti. Une première connexion sera donc faites pour "récupérer" la donnée en connectant le port de l'ordonnanceur avec le port de sorti de l'instance qui doit émettre la donnée, puis lorsque l'instance qui dispose du port qui attend la donnée aura ses ressources affrétées ou bien à un autre moment si on le décide, une nouvelle connexion sera effectué entre le port de l'ordonnanceur et le port de l'instance de manière à ce que ce dernier reçoive la donnée attendue.



\part{Contribution à la création d'action de gestions et de stratégie }

\section{Définition des actions de gestion du cycle de vie des composants}

\subsection{Création de composant}
Le démarrage d'un composant consiste a allouer les ressources nécessaire au fonctionnement de l'application sur une machine, de démarrer l'application sur celle-ci et de lui attribuer les ressources.\\
Au sein du code, démarrer le composant sera une action qui pourra s'effectuer à l'aide de l'objet instance, qui contiendra les informations nécessaire telle que les ressources nécessaire, ou comment démarrer l'application. Le démarrage d'une application consiste seulement à démarrer l'application avec des ressources déterminée sur une machine déterminée, en aucun cas l'application n'est lancer à cette étape.\\
Algorithmiquement ce sera une fonction sous la forme :
\begin{lstlisting}[]
startInstance(Instance i){
    if (!empty(listComponentStartedAndReferences.get(i))){
      Ressources r = i.getNecessaryRessource();
      Machine m = this.getMachineWithDisponibleRessource(r);
      typeOpaque componentStart = m.startComponent(i.getStartingParameters);
      listComponentStartedAndReferences.add(i, componentStart);
      m.useRessource(r);
    }
}
\end{lstlisting}
NB : la fonction startComponent() doit fournir au composant lancer un type opaque spécifique pour chaque composant, qui permettra la communication avec l'ordonnanceur, ce type opaque représente l'interface qu'offre l'ordonnanceur au composant pour lui communiqué ses données sortantes.\\
listComponentStartedAndReferences est un hashMap qui pour une instance clé renvoie la valeur typeOpaque correspondante.

\subsection{Connexion des ports de sorties}

\subsection{Envoie de données à un composant}
L'envoie de donnée consiste via une opération à permettre à un composant d'accéder à une donnée dont il a besoin pour fonctionner. Dans le cadre d'un ordonnanceur centralisé il s'agit d'envoyer depuis l'ordonnanceur, une donnée, vers le composant et ceux à l'aide d'une opération disponible via l'utilisation d'un type opaque correspondant à l'instance en cour du composant.\\
Ce type opaque peut être récupéré dans le hashMap des composant démarré et de leur référence. Il est égalemment nécessaire d'avoir le nom du port afin de savoir quelle opération doit être appelée\\
Algorithmiquement un envoi de donnée ce déroulera de la manière suivante :
\begin{lstlisting}[]
//i est l'instance du composant a laquelle nous voulons envoyer des donnees.

TypeOpaque componentStart = listComponentStartedAndReferences.get(i);
sendDataToInstance(data, componentStart, port);

sendDataToInstance(Data d, TypeOpaque componentStart, Port p){
    if (!empty(listDataSend.get(componentStart, p))){
      operationForSend oP = componentStart.getOperation(p);
      componentStart.oP(d);
      listDataSend.add(componentStart, p, true);
    }
}
\end{lstlisting}
NB : listDataSend est un hashMap qui pour un typeOpaque de composant démarré et un port clé, renvoie le booléen true si la valeur à bien était envoyé.

\subsection{Positionner les données en entrée d'une classe}
Consiste à envoyé toute les données demandées par un composant donné, une fois cela effectué le composant doit démarrer seul si ce n'est pas le cas c'est lié à un problème d'implémentation qui ne nous concerne pas.\\
Algorithme :
\begin{lstlisting}[]

lancement(instance i){
    TypeOpaque comp = listComponentStartedAndReferences.get(i);
    if (comp == null){
        startInstance(i);
    }
    for (each Port p in comp){
        for (each ConfigPort cp in this){
            if (cp.in == p){
                sendDataToInstance(listDataReceiv
                (cp.out.getInstance()), cp.out.getPort());
            }
        }
    }
\end{lstlisting}
NB : listDataReceiv(instance, port) est une fonction qui pour une instance et un port de sortie donnée renvoi la valeur que l'application a transmise si elle en a transmise une et null sinon.

\subsection{Réception de données d'un composant}
La réception d'une donnée d'un composant consiste à attendre l'appel d'une opération fourni par le type opaque offert a l'application lors de son démarrage. Pour cela il est nécessaire que l'ordonnanceur implémente toute ces opérations, ainsi il y a pour chaque port de chaque instance une fonction a implémenté, les noms peuvent être potentiellement similaire car ils sont proposé au travers d'un type opaque qui sera différent pour chaque composant.


\subsection{Destruction d'une instance de composant}
La fin d'un composant ne peut-être faite que lorsque toute les données sortante d'un composant ont été réceptionnées. Cette fin de composant consiste à mettre fin à l'application et de libérer les ressources qui ont été allouées pour son fonctionnement.

\subsection{Optionnel}

\subsubsection{Appel de services}

\subsubsection{Réponses de services}

\pagebreak
\section{Application de stratégies d'ordonnancement}

\subsection{Stratégie 1 : gloutonne}
Cette stratégie consiste à créer tout les composants, sans ce soucier de la mémoire utilisée par tout ceci, on considère que nous avons les ressources nécessaire pour que tout fonctionne en synchronisation. Une fois cela fait, on suit les instructions et lorsqu'une application doit être lancer on effectue tout les envois de données nécessaire, si il manque des données on attend jusqu'à les avoir disponible (sauf si elles sont optionnelles). Puis toute les application prennent fin lorsque l'ensemble du workflow a été effectué.\\
\subsubsection{Actions a mener pour appliquer la stratégie}
\begin{itemize}
    \item Démarrage de tout les composants présent dans l'assemblage, sans distinction et en même temps.
    \item ...
\end{itemize}
\subsubsection{Avantages}
\begin{itemize}
    \item Facilité de gestion, on a pas a déterminer le moment ou les tâches sont démarrées et termine.
    \item Vitesse, tout est lancé dés le départ il n'y a pas de temps d'attente pour démarrer des composants en cour de route.
    \item Ressources constante, on sait les ressources dont on va avoir besoin du début à la fin et elle ne vont pas varier.
\end{itemize}
\subsubsection{Défauts}
\begin{itemize}
    \item Utilisation importante des ressources.
    \item Même lorsqu'on en a plus l'utilité les composants continu de fonctionner.
    \item Aucune optimisation, si dans une séquence un composant à besoin d'une donnée qui n'arrivera que dans 10 minutes alors que pour le composant suivant on à toute les données on ne lance tout de même pas le composant suivant.
\end{itemize}
\subsection{Stratégie 2 : Logique}
Cette stratégie consiste a suivre le flot de contrôle, on ne cherche pas a optimiser les choses ni a appliquer de raccourcis, on démarre les application lorsqu'on le demande explicitement ou qu'on doit les lancer, on termine avec une application lorsque c'est demandé explicitement. Les ressources ne sont la encore pas à considérer on prend en compte le fait que si on nous demande d'effectuer un démarrage, les ressources nécessaire a ce démarrage sont disponible.
\subsubsection{Actions a mener pour appliquer la stratégie}

\subsubsection{Avantages}
\begin{itemize}
    \item Respecte forcement le schéma demandé.
    \item Il y a un cheminement ordonner.
\end{itemize}

\subsubsection{Défauts}
\begin{itemize}
    \item Ne fait aucune optimisation.
    \item Utilise de plus en plus de ressources.
\end{itemize}

\subsection{Stratégie 3 : Logique avancé}
Cette stratégie à un comportement relativement similaire à la stratégie 2, il y a cependant des actions supplémentaires qui sont effectuée. On démarre une instance uniquement lorsque on va la lancer juste après, et lorsque une application à retournée l'ensemble des valeurs qu'elle devait retournée on la termine et on libère la ressource.
\subsubsection{Actions a mener pour appliquer la stratégie}

\subsubsection{Avantages}
\begin{itemize}
    \item Libération des ressources.
\end{itemize}

\subsubsection{Défauts}
\begin{itemize}
    \item On ne connais pas la ressource qui sera utilisée à un moment donné.
\end{itemize}

\subsection{Stratégie 4 : Parallélisation}
On effectue les actions de manière similaire à la stratégie 3 mais en plus de cela on parallélise les séquences lorsque c'est possible.
\subsubsection{Actions a mener pour appliquer la stratégie}

\subsubsection{Avantages}
\begin{itemize}
    \item Accélère l'exécution du workflow.
    \item Cela reste une opération logique, cette stratégie obtiendra le même résultats à la fin de l'exécution du workflow qu'avec une stratégie n'optimisant pas cela.
\end{itemize}

\subsubsection{Défauts}
\begin{itemize}
    \item Ne respecte pas parfaitement le schéma inscrit dans le XML.
    \item Demande de reparcourir plusieurs fois les instructions on ne peut donc pas faire en sorte d'agir comme avec une pile.
\end{itemize}
\pagebreak

\section{La perspective de transition dans l'univers distribué}
\subsection{Présentation}
\subsection{Adaptabilité du projet}
\subsection{Actions}
\subsection{Stratégie}
\subsection{Conclusion}

\fi
%--------------------------------------%
\end{document}
